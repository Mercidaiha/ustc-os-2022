复习：进程通信（协同进程，方式，例子pipe）
ipci问题：竞争条件
	并发访问
		存储的层次（cpu执行流程）
		结果取决于顺序
		常见
进程同步
	根源：多个进程同时访问共享资源
	思想：避免同时访问（互斥）
	特例：不可抢占内存
如何实现互斥？
	定义临界区（critical section）：结构？（包括识别出的临界区，进入和退出的控制）
	临界区代码互斥
	核心任务：entry和exit的实现
		实现方法：
			要求：
				1.互斥
				2.执行速度无限制
				3.进步
				4.有限等待 bounded waiting（避免饿死）
			硬件方案：
				test_and_set(&lock) 原子
				compare_and_swap()
				如何用？=> entry/exit
			软件方案：
				特例（不允许中断）
				互斥锁 => 自旋锁（多核+锁存表时间短）
				严格轮换
					思想：轮流执行（忙等）
					问题：效率。要求是否满足？（互斥√ 进步×）
				peterson解决方案：
					思想：礼让
					如何表达？判断需求（共享变量）+ turn变量
					要求是否满足？作业
					问题：忙等（cpu开销）+ 优先级翻转
	信号量：
		概念：类似于交通管控
			数据类型：“整数”，代表共享资源的数量
				二进制信号量（状态）+ 计数型	
		如何用：
			p/v操作
			进去-1：down() / P /wait() 操作更多
			退出+1：up() / V /signal()
		代码实现：
			忙等-队列-信号量（整数+队列fifo）
			原子-不允许中断
	小结：P/V（原子）
		信号量的使用：互斥+计数+同步
		多个（协调）：互斥+计数
	死锁：
		要求：
			资源访问互斥
			持有并等待 1：持有a等待b 2：持有b等待a
			不允许抢占
			循环等待
		如何解决死锁：
			检测-恢复 + 预防/避免 + 忽略（简单，权衡，比如kill）
		思路：刻画系统（资源分配）
	     



资源分配图：
	节点：进程，资源
	边：请求边，分配边
	用处：检测死锁（圈）<= 单实例
对于多实例，怎么看？
	矩阵
		E:总资源
		A:可用资源
		C：分配情况
		R：请求
          算法
	

避免：银行家算法
	分配时进行判断
	思想：检测分配后的状态（E,A,C,R）
			安全状态：存在执行序列
			不安全状态
	算法流程
忽略：鸵鸟算法

IPC-互斥-临界区-软硬件（信号量）

生产者-消费者（多个）
分析：互斥+同步
             |   |
二进制信号量 计数型信号量（2个）
mutex互斥锁
信号量的使用（死锁）

哲学家用餐问题
	互斥（共享对象），也就是不能共享筷子                          死锁
	solution1：检查筷子使用情况，有人用就等待，无人就同时拿
	同步：（释放占用资源）                                                  循环
	最终：刻画哲学家状态
		进入：该状态（变成饥饿），检查状态（左右状态），如果能，则eating，并且释放一个共享资源
		退出：            （变成思考），左右进入test
	
读者-写者问题
	问题描述 读者（并发） 写者（互斥）
	互斥同步并发
  